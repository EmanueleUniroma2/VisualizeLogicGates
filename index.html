<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LogicSim JS v14 - Hybrid Compiler</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-color: #252526;
            --accent-color: #007acc;
            --text-color: #d4d4d4;
            --wire-off: #555;
            --wire-on: #4caf50;
            --clock-color: #8e44ad;
            --danger-color: #d9534f;
            --test-color: #ff9800;
        }
        body { margin: 0; background: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; }
        
        #sidebar { width: 240px; background: var(--panel-color); padding: 10px; border-right: 1px solid #333; display: flex; flex-direction: column; gap: 5px; overflow-y: auto; z-index: 10; box-shadow: 2px 0 5px rgba(0,0,0,0.5);}
        h3 { font-size: 0.9rem; color: #888; text-transform: uppercase; margin: 15px 0 5px 0; border-bottom: 1px solid #444; }
        
        .comp-btn { 
            background: #333; color: white; border: 1px solid #444; padding: 6px; cursor: pointer; 
            display: flex; align-items: center; justify-content: space-between; border-radius: 4px; transition: 0.2s;
            min-height: 30px;
        }
        .comp-btn:hover { background: #444; }
        .comp-label { display: flex; align-items: center; gap: 10px; flex-grow: 1; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        
        .btn-group { display: flex; gap: 4px; }
        .icon-btn { 
            padding: 4px 6px; border-radius: 3px; cursor: pointer; font-size: 12px; 
            background: #555; border: none; color: white; display: flex; align-items: center; justify-content: center;
        }
        .icon-btn:hover { background: var(--accent-color); }
        .icon-btn.delete:hover { background: var(--danger-color); }
        .icon-btn.test:hover { background: var(--test-color); }
        
        .icon-indicator { width: 10px; height: 10px; border-radius: 50%; display: inline-block; flex-shrink: 0; }

        .lib-actions { display: flex; gap: 5px; margin-bottom: 5px; }
        .lib-btn { flex: 1; text-align: center; justify-content: center; font-size: 0.85rem; background: #3a3a3a; }
        .lib-btn:hover { background: #505050; }

        #canvas-box { flex-grow: 1; position: relative; overflow: hidden; cursor: grab; }
        #canvas-box:active { cursor: grabbing; }

        #c { display: block; background-color: var(--bg-color); background-image: radial-gradient(#444 1px, transparent 1px); background-size: 20px 20px; }
        
        #toolbar { position: absolute; top: 10px; right: 10px; display: flex; gap: 10px; z-index: 10;}
        .tool-btn { padding: 8px 16px; background: var(--accent-color); border: none; color: white; border-radius: 4px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.3);}
        .tool-btn.danger { background: var(--danger-color); }
        
        #status { position: fixed; bottom: 10px; right: 10px; background: #333; padding: 5px 12px; border-radius: 20px; font-size: 0.85em; opacity: 0.8; border: 1px solid #555; pointer-events: none; user-select: none;}
        
        .hint { font-size: 0.75rem; color: #777; margin-top: 5px; text-align: center; font-style: italic;}
    </style>
</head>
<body>

<div id="sidebar">
    <h3>I/O</h3>
    <div class="comp-btn" onclick="app.setMode('Input')">
        <div class="comp-label"><span class="icon-indicator" style="background:green"></span>Switch</div>
    </div>
    <div class="comp-btn" onclick="app.setMode('Clock')">
        <div class="comp-label"><span class="icon-indicator" style="background:var(--clock-color)"></span>Clock</div>
    </div>
    <div class="comp-btn" onclick="app.setMode('Output')">
        <div class="comp-label"><span class="icon-indicator" style="background:orange"></span>Light</div>
    </div>
    
    <h3>Logic Gates</h3>
    <div class="comp-btn" onclick="app.setMode('AND')"><div class="comp-label">AND</div></div>
    <div class="comp-btn" onclick="app.setMode('OR')"><div class="comp-label">OR</div></div>
    <div class="comp-btn" onclick="app.setMode('NOT')"><div class="comp-label">NOT</div></div>
    <div class="comp-btn" onclick="app.setMode('NAND')"><div class="comp-label">NAND</div></div>
    <div class="comp-btn" onclick="app.setMode('NOR')"><div class="comp-label">NOR</div></div>
    <div class="comp-btn" onclick="app.setMode('XOR')"><div class="comp-label">XOR</div></div>

    <h3>My Chips</h3>
    <div class="lib-actions">
        <div class="comp-btn lib-btn" onclick="app.exportLib()">â¬‡ Export</div>
        <div class="comp-btn lib-btn" onclick="app.importLib()">â¬† Import</div>
    </div>
    <div id="custom-list"></div>
    <div class="hint">Double Click: Rename<br>Drag BG: Pan<br>Right Click: Delete</div>
</div>

<div id="canvas-box">
    <div id="toolbar">
        <button class="tool-btn" onclick="app.saveChip()">Save Chip</button>
        <button class="tool-btn danger" onclick="app.clear()">Clear All</button>
    </div>
    <canvas id="c"></canvas>
    <div id="status">Ready</div>
</div>

<script>
const dist = (x1, y1, x2, y2) => Math.hypot(x2-x1, y2-y1);

// --- COMPILER & VM ENGINE ---
// Ops Codes: 0:AND, 1:OR, 2:NOT, 3:NAND, 4:NOR, 5:XOR
const OP_AND=0, OP_OR=1, OP_NOT=2, OP_NAND=3, OP_NOR=4, OP_XOR=5;

class Compiler {
    static compile(blueprint, lib) {
        // This flattens the entire hierarchy into a single instruction list
        const ctx = {
            wires: [],      // Array of wire values (simulated memory)
            ops: [],        // [OP_CODE, IN1, IN2, OUT, ...]
            nextWireId: 0,
            hasClock: false
        };
        
        // Reserve wires for Main Chip Inputs
        const inputWireIds = [];
        for(let i=0; i<blueprint.inputCount; i++) inputWireIds.push(ctx.nextWireId++);

        // Compile Body
        const outputWireIds = this.compileNodeRecursively(blueprint, ctx, inputWireIds, lib);
        
        return {
            ops: new Int32Array(ctx.ops),
            wireCount: ctx.nextWireId,
            inputs: inputWireIds,
            outputs: outputWireIds,
            hasClock: ctx.hasClock
        };
    }

    static compileNodeRecursively(bp, ctx, inputWires, lib) {
        let data = bp.circuitData;
        if(typeof data === 'string') try { data = JSON.parse(data); } catch(e){ data = {nodes:[], wires:[]}; }

        // 1. Map local nodes to their Output Wire IDs
        const localNodeOutputs = {}; // nodeId -> [wireId, wireId...]
        
        // Pre-allocate output wires for all nodes in this layer
        data.nodes.forEach(n => {
            if(n.type === 'Input') {
                // Inputs are already provided by `inputWires` arg, but we need to map the ID
                // actually, inputs in `data.nodes` act as sources.
                // We will assign them the IDs passed from parent.
            } else {
                const pinCount = (n.type === 'Custom' || n.type === 'CustomChip') 
                    ? (n.blueprint?.outputCount || 0) 
                    : (n.type === 'NOT' || n.type === 'Output' ? 1 : 1);
                
                const outs = [];
                for(let i=0; i<pinCount; i++) outs.push(ctx.nextWireId++);
                localNodeOutputs[n.id] = outs;
                
                if(n.type === 'Clock') ctx.hasClock = true;
            }
        });

        // 2. Resolve internal connections (Wires -> "Netlist")
        // We need to know "NodeID:Pin" -> "WireID"
        const getInputWireForNode = (nodeId, pinIdx) => {
            // Find the wire in this circuit that connects TO this node/pin
            const wire = data.wires.find(w => w.toNodeId === nodeId && w.toPin === pinIdx);
            if(!wire) return -1; // Floating input

            const srcNode = data.nodes.find(n => n.id === wire.fromNodeId);
            if(!srcNode) return -1;

            if(srcNode.type === 'Input') {
                // Determine which Input Index this node corresponds to
                // We assume inputs are sorted by Y usually, but let's trust the array order or label?
                // LogicSim stores them in list. We need index.
                const inputNodes = data.nodes.filter(n => n.type === 'Input').sort((a,b)=>a.y - b.y);
                const idx = inputNodes.indexOf(srcNode);
                return (idx >= 0 && idx < inputWires.length) ? inputWires[idx] : -1;
            } else {
                return localNodeOutputs[srcNode.id] ? localNodeOutputs[srcNode.id][wire.fromPin] : -1;
            }
        };

        // 3. Generate Ops
        data.nodes.forEach(n => {
            if(n.type === 'Input' || n.type === 'Output' || n.type === 'Clock') return; // Handled structurally

            if(n.type === 'Custom' || n.type === 'CustomChip') {
                // RECURSION: Compile the sub-chip inline
                // 1. Gather inputs for sub-chip
                const subBp = lib[n.blueprint.name] || n.blueprint;
                const subInputs = [];
                for(let i=0; i<subBp.inputCount; i++) {
                    subInputs.push(getInputWireForNode(n.id, i));
                }
                
                // 2. Recurse
                const subOutputs = this.compileNodeRecursively(subBp, ctx, subInputs, lib);
                
                // 3. Link sub-outputs to local outputs (Buffer op: out = in)
                // This is a "Move" op to map the recursion result to the allocated wire
                const allocated = localNodeOutputs[n.id];
                for(let i=0; i<allocated.length; i++) {
                    if(i < subOutputs.length) {
                         // Optimization: Direct wire aliasing would be better, but OR/Buffer is safer for now
                         // We insert a "Buffer" (OR with 0 or AND with 1, or just NOT NOT). 
                         // To keep VM simple, we just use OR with itself. A | A = A.
                         ctx.ops.push(OP_OR, subOutputs[i], subOutputs[i], allocated[i]);
                    }
                }
            } else {
                // Primitive Gate
                const w1 = getInputWireForNode(n.id, 0);
                const w2 = (n.type !== 'NOT') ? getInputWireForNode(n.id, 1) : -1;
                const out = localNodeOutputs[n.id][0];

                if(w1 === -1 && w2 === -1) return; // Disconnected gate

                let op = -1;
                switch(n.type) {
                    case 'AND': op = OP_AND; break;
                    case 'OR':  op = OP_OR; break;
                    case 'NOT': op = OP_NOT; break;
                    case 'NAND': op = OP_NAND; break;
                    case 'NOR': op = OP_NOR; break;
                    case 'XOR': op = OP_XOR; break;
                }
                if(op !== -1) ctx.ops.push(op, w1, w2 !== -1 ? w2 : w1, out); // Use w1 twice for NOT if needed
            }
        });

        // 4. Gather Outputs of this block to return to parent
        const outputNodes = data.nodes.filter(n => n.type === 'Output').sort((a,b)=>a.y - b.y);
        const resultWires = outputNodes.map(n => getInputWireForNode(n.id, 0));
        return resultWires;
    }
}
// ----------------------------

class Node {
    constructor(x, y, type, id = null, label = null) {
        this.id = id || Math.random().toString(36).substr(2, 9);
        this.x = x; this.y = y;
        this.type = type;
        this.label = label || type;
        this.w = 60; this.h = 40;
        this.state = 0; 
        this.currentValue = 0; 
        if (this.type === 'Clock') {
            this.frequency = 1; 
            this.lastTick = Date.now();
        }
        this.ins = []; this.outs = [];
        this.setupPins();
    }

    setupPins() {
        if (this.type === 'Input' || this.type === 'Clock') {
            this.outs = [{x:60, y:20}];
        } else if (this.type === 'Output') {
            this.ins = [{x:0, y:20}];
        } else if (this.type === 'NOT') { 
            this.ins = [{x:0, y:20}]; this.outs = [{x:60, y:20}]; 
        } else { 
            this.ins = [{x:0, y:10}, {x:0, y:30}]; 
            this.outs = [{x:60, y:20}]; 
        }
    }

    compute(inputs) {
        const a = inputs[0] || 0;
        const b = inputs[1] || 0;
        switch(this.type) {
            case 'Input': 
            case 'Clock': return [this.state];
            case 'Output': this.currentValue = a; return [];
            case 'AND': return [a && b ? 1 : 0];
            case 'OR': return [a || b ? 1 : 0];
            case 'NOT': return [a ? 0 : 1];
            case 'NAND': return [!(a && b) ? 1 : 0];
            case 'NOR': return [!(a || b) ? 1 : 0];
            case 'XOR': return [a ^ b ? 1 : 0];
            default: return [0];
        }
    }
}

class CustomChip extends Node {
    constructor(x, y, blueprint, id = null) {
        super(x, y, 'Custom', id, blueprint.name);
        
        const lib = JSON.parse(localStorage.getItem('ls_lib') || '{}');
        const latestBlueprint = lib[blueprint.name] || blueprint;
        this.blueprint = latestBlueprint;

        this.inputLabels = this.blueprint.inputLabels || [];
        this.outputLabels = this.blueprint.outputLabels || [];

        const maxPins = Math.max(this.inputLabels.length, this.outputLabels.length);
        this.h = Math.max(40, maxPins * 20 + 20);
        this.w = 100; 

        this.ins = [];
        for(let i=0; i<this.inputLabels.length; i++) this.ins.push({x:0, y: (this.h/(this.inputLabels.length+1))*(i+1)});
        this.outs = [];
        for(let i=0; i<this.outputLabels.length; i++) this.outs.push({x:this.w, y: (this.h/(this.outputLabels.length+1))*(i+1)});

        // --- HYBRID COMPILATION ---
        // 1. Compile to Flattened Bytecode
        this.program = Compiler.compile(this.blueprint, lib);
        
        // 2. Allocate Fast Memory
        this.memory = new Int8Array(this.program.wireCount);
        
        // 3. Truth Table Optimization (for small, combinatorial chips)
        this.truthTable = null;
        this.useTruthTable = false;

        if(!this.program.hasClock && this.inputLabels.length <= 10) {
            this.buildTruthTable();
            this.useTruthTable = true;
        }

        // Clock handling for internal clocks inside the flat list (not fully supported in flat VM yet, 
        // effectively flattening removes clocks unless we map them. 
        // For now, if hasClock, we rely on the parent tick to re-run the VM).
    }

    buildTruthTable() {
        const inputs = this.inputLabels.length;
        const rows = 1 << inputs; // 2^inputs
        // Store outputs packed? Or simple array of arrays. 
        // For speed, let's use a flat Uint8Array: row * outputCount + outIdx
        this.truthTable = new Uint8Array(rows * this.outputLabels.length);
        
        for(let i=0; i<rows; i++) {
            // 1. Set Inputs
            for(let b=0; b<inputs; b++) {
                this.memory[this.program.inputs[b]] = (i >> b) & 1;
            }
            // 2. Run VM
            this.runVM();
            // 3. Store Outputs
            for(let o=0; o<this.outputLabels.length; o++) {
                this.truthTable[i * this.outputLabels.length + o] = this.memory[this.program.outputs[o]];
            }
        }
    }

    runVM() {
        const ops = this.program.ops;
        const mem = this.memory;
        for(let i=0; i<ops.length; i+=4) {
            const op = ops[i];
            const v1 = mem[ops[i+1]];
            const v2 = mem[ops[i+2]];
            let res = 0;
            switch(op) {
                case 0: res = v1 & v2; break; // AND
                case 1: res = v1 | v2; break; // OR
                case 2: res = v1 ? 0 : 1; break; // NOT
                case 3: res = (v1 & v2) ? 0 : 1; break; // NAND
                case 4: res = (v1 | v2) ? 0 : 1; break; // NOR
                case 5: res = v1 ^ v2; break; // XOR
            }
            mem[ops[i+3]] = res;
        }
    }

    compute(inputs) {
        // --- FAST PATH 1: TRUTH TABLE ---
        if(this.useTruthTable) {
            let idx = 0;
            for(let i=0; i<inputs.length; i++) {
                if(inputs[i]) idx |= (1 << i);
            }
            const offset = idx * this.outputLabels.length;
            const res = [];
            for(let i=0; i<this.outputLabels.length; i++) res.push(this.truthTable[offset+i]);
            return res;
        }

        // --- FAST PATH 2: BYTECODE VM ---
        // 1. Load Inputs
        for(let i=0; i<inputs.length; i++) {
            this.memory[this.program.inputs[i]] = inputs[i] || 0;
        }

        // 2. Execute Linear Ops (No recursion, No objects)
        this.runVM();

        // 3. Read Outputs
        const res = [];
        for(let i=0; i<this.outputLabels.length; i++) {
            res.push(this.memory[this.program.outputs[i]]);
        }
        return res;
    }
}

const app = {
    c: document.getElementById('c'),
    ctx: document.getElementById('c').getContext('2d'),
    nodes: [],
    wires: [],
    mode: null,
    blueprint: null,
    tempWire: null,
    hoverPin: null,
    currentEditName: null, 
    offsetX: 0,
    offsetY: 0,
    isPanning: false,
    lastMouse: {x:0, y:0},

    init() {
        this.resize();
        window.onresize = () => this.resize();
        this.loadLibUI();
        this.loop();
        
        this.c.onmousedown = e => this.handleDown(e);
        this.c.onmousemove = e => this.handleMove(e);
        this.c.onmouseup = e => this.handleUp(e);
        this.c.oncontextmenu = e => { e.preventDefault(); this.handleRightClick(e); };
        this.c.ondblclick = e => this.handleDblClick(e);
    },

    resize() {
        this.c.width = this.c.parentElement.clientWidth;
        this.c.height = this.c.parentElement.clientHeight;
    },

    setMode(m, bp = null) { 
        this.mode = m; 
        this.blueprint = bp;
        document.getElementById('status').innerText = m ? `Placing: ${bp ? bp.name : m}` : "Ready";
    },

    getWorldPos(e) {
        const r = this.c.getBoundingClientRect();
        return {
            x: (e.clientX - r.left) - this.offsetX,
            y: (e.clientY - r.top) - this.offsetY
        };
    },

    addNode(x, y) {
        if(this.mode === 'Custom') this.nodes.push(new CustomChip(x, y, this.blueprint));
        else this.nodes.push(new Node(x, y, this.mode));
        this.setMode(null);
        this.propagate();
    },

    updateClocks() {
        const now = Date.now();
        let changed = false;
        this.nodes.forEach(n => {
            if (n.type === 'Clock') {
                const halfPeriod = (1000 / n.frequency) / 2;
                if (now - n.lastTick > halfPeriod) {
                    n.state = !n.state;
                    n.lastTick = now;
                    changed = true;
                }
            }
            // If custom chip has internal clock, we just re-run it? 
            // In flattened VM, we don't handle internal clock events easily yet. 
            // It relies on inputs changing.
        });
        if (changed) this.propagate();
    },

    propagate() {
        // Just a few passes are needed now because sub-chips are atomic/instant
        const passes = this.nodes.length + 5;
        
        for(let i=0; i<passes; i++) {
            this.nodes.forEach(n => {
                const inputs = n.ins.map((_, idx) => {
                    const w = this.wires.find(w => w.toNode === n && w.toPin === idx);
                    return w ? w.value : 0;
                });
                const outputs = n.compute(inputs);
                outputs.forEach((val, idx) => {
                    this.wires.filter(w => w.fromNode === n && w.fromPin === idx)
                              .forEach(w => w.value = val);
                });
            });
        }
    },

    // Culling
    isVisible(x, y, w, h) {
        const sx = x + this.offsetX;
        const sy = y + this.offsetY;
        return (sx + w > 0 && sx < this.c.width && sy + h > 0 && sy < this.c.height);
    },

    drawGateShape(ctx, n) {
        ctx.beginPath();
        const x = n.x, y = n.y, w = n.w, h = n.h;
        if(n.type === 'Custom' || n.type === 'Input' || n.type === 'Output' || n.type === 'Clock') {
            ctx.rect(x, y, w, h);
            return;
        }
        if (n.type === 'AND' || n.type === 'NAND') {
            ctx.moveTo(x, y); ctx.lineTo(x + w/2, y);
            ctx.arc(x + w/2, y + h/2, h/2, -Math.PI/2, Math.PI/2);
            ctx.lineTo(x, y + h); ctx.closePath();
        } 
        else if (n.type === 'OR' || n.type === 'NOR') {
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(x + w/4, y + h/2, x, y + h); 
            ctx.quadraticCurveTo(x + w/2, y + h - 5, x + w, y + h/2);
            ctx.quadraticCurveTo(x + w/2, y + 5, x, y); 
            ctx.closePath();
        }
        else if (n.type === 'XOR') {
            const off = 6;
            ctx.moveTo(x + off, y);
            ctx.quadraticCurveTo(x + w/4 + off, y + h/2, x + off, y + h);
            ctx.quadraticCurveTo(x + w/2 + off, y + h - 5, x + w, y + h/2);
            ctx.quadraticCurveTo(x + w/2 + off, y + 5, x + off, y);
            ctx.closePath();
        }
        else if (n.type === 'NOT') {
            ctx.moveTo(x, y); ctx.lineTo(x + w - 10, y + h/2); ctx.lineTo(x, y + h); ctx.closePath();
        }
    },

    drawDecorations(ctx, n) {
        if (n.type === 'XOR') {
            ctx.beginPath(); ctx.strokeStyle = '#ccc'; ctx.lineWidth = 2;
            ctx.moveTo(n.x - 4, n.y);
            ctx.quadraticCurveTo(n.x + n.w/4 - 4, n.y + n.h/2, n.x - 4, n.y + n.h);
            ctx.stroke();
        }
        if (n.type === 'NAND' || n.type === 'NOR' || n.type === 'NOT') {
            ctx.beginPath(); ctx.fillStyle = '#1e1e1e'; ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
            let bx = n.x + n.w, by = n.y + n.h/2;
            if (n.type === 'NOT') bx = n.x + n.w - 5;
            ctx.arc(bx, by, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        }
        if (n.type === 'Custom') {
            ctx.fillStyle = '#fff'; ctx.font = '10px monospace';
            ctx.textAlign = 'left';
            n.inputLabels.forEach((lbl, i) => { ctx.fillText(lbl, n.x + 5, n.y + n.ins[i].y + 3); });
            ctx.textAlign = 'right';
            n.outputLabels.forEach((lbl, i) => { ctx.fillText(lbl, n.x + n.w - 5, n.y + n.outs[i].y + 3); });
        }
    },

    loop() {
        this.updateClocks();
        const ctx = this.ctx;
        this.c.style.backgroundPosition = `${this.offsetX}px ${this.offsetY}px`;
        ctx.clearRect(0,0, this.c.width, this.c.height);
        ctx.save();
        ctx.translate(this.offsetX, this.offsetY);
        
        this.wires.forEach(w => {
            if(!this.isVisible(w.fromNode.x, w.fromNode.y, w.fromNode.w, w.fromNode.h) && 
               !this.isVisible(w.toNode.x, w.toNode.y, w.toNode.w, w.toNode.h)) return;

            const start = {x: w.fromNode.x + w.fromNode.outs[w.fromPin].x, y: w.fromNode.y + w.fromNode.outs[w.fromPin].y};
            const end = {x: w.toNode.x + w.toNode.ins[w.toPin].x, y: w.toNode.y + w.toNode.ins[w.toPin].y};
            ctx.beginPath();
            ctx.strokeStyle = w.value ? 'var(--wire-on)' : 'var(--wire-off)';
            ctx.lineWidth = 3;
            ctx.moveTo(start.x, start.y);
            ctx.bezierCurveTo(start.x+40, start.y, end.x-40, end.y, end.x, end.y);
            ctx.stroke();
        });

        if(this.tempWire) {
            const start = {x: this.tempWire.node.x + (this.tempWire.isInput?this.tempWire.node.ins:this.tempWire.node.outs)[this.tempWire.idx].x, y: this.tempWire.node.y + (this.tempWire.isInput?this.tempWire.node.ins:this.tempWire.node.outs)[this.tempWire.idx].y};
            ctx.beginPath(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
            ctx.moveTo(start.x, start.y); ctx.lineTo(this.tempWire.mx, this.tempWire.my); ctx.stroke();
        }

        this.nodes.forEach(n => {
            if(!this.isVisible(n.x, n.y, n.w, n.h)) return;

            this.drawGateShape(ctx, n);
            ctx.fillStyle = '#333'; 
            ctx.strokeStyle = (n === this.dragNode) ? '#fff' : '#ccc';
            if(n.type === 'Clock') ctx.strokeStyle = 'var(--clock-color)';
            ctx.lineWidth = 2;
            ctx.fill(); ctx.stroke();
            this.drawDecorations(ctx, n);
            
            ctx.fillStyle = '#aaa'; ctx.textAlign = 'center'; ctx.font = '11px sans-serif';
            let label = n.label;
            if(n.type === 'Clock') label = `${n.frequency}Hz`;
            ctx.fillText(label, n.x+n.w/2, n.y + n.h + 15);
            
            if(n.type === 'Input') { ctx.fillStyle = n.state ? '#0f0' : '#222'; ctx.fillRect(n.x+10, n.y+10, 20, 20); }
            if(n.type === 'Clock') { ctx.fillStyle = n.state ? '#d2a4ff' : '#4a235a'; ctx.fillRect(n.x+10, n.y+10, 20, 20); }
            if(n.type === 'Output') { ctx.fillStyle = n.currentValue ? '#ff0' : '#220'; ctx.beginPath(); ctx.arc(n.x+n.w/2, n.y+n.h/2, 10, 0, Math.PI*2); ctx.fill(); }
            
            const drawP = (pins, isInput) => pins.forEach((p, i) => {
                const px = n.x + p.x, py = n.y + p.y;
                const hov = this.hoverPin && this.hoverPin.node === n && this.hoverPin.idx === i && this.hoverPin.isInput === isInput;
                ctx.fillStyle = hov ? '#fff' : '#999';
                const s = hov ? 10 : 6;
                ctx.fillRect(px-s/2, py-s/2, s, s);
            });
            drawP(n.ins, true); drawP(n.outs, false);
        });
        ctx.restore(); 
        requestAnimationFrame(() => this.loop());
    },

    hitTestPin(mx, my) {
        for(let n of this.nodes) {
            if(!this.isVisible(n.x, n.y, n.w, n.h)) continue;

            for(let i=0; i<n.ins.length; i++) {
                const p = n.ins[i];
                if(dist(mx, my, n.x+p.x, n.y+p.y) < 15) return {node:n, idx:i, isInput:true};
            }
            for(let i=0; i<n.outs.length; i++) {
                const p = n.outs[i];
                if(dist(mx, my, n.x+p.x, n.y+p.y) < 15) return {node:n, idx:i, isInput:false};
            }
        }
        return null;
    },

    handleDown(e) {
        if(e.button === 2) return;
        const world = this.getWorldPos(e);
        const pin = this.hitTestPin(world.x, world.y);
        if(pin) { this.tempWire = {...pin, mx:world.x, my:world.y}; return; }
        for(let i = this.nodes.length-1; i>=0; i--) {
            const n = this.nodes[i];
            if(world.x>=n.x && world.x<=n.x+n.w && world.y>=n.y && world.y<=n.y+n.h) {
                if(n.type === 'Input') { n.state = !n.state; this.propagate(); }
                else if (n.type === 'Clock') {
                    const input = prompt(`Frequency (0.01Hz - 5Hz)`, n.frequency);
                    if (input !== null) { const val = parseFloat(input); if(val >= 0.01 && val <= 5) n.frequency = val; }
                } 
                else { this.dragNode = n; this.dragOffset = {x: world.x-n.x, y: world.y-n.y}; }
                return;
            }
        }
        if(this.mode) { this.addNode(world.x-30, world.y-20); return; }
        this.isPanning = true; this.lastMouse = {x: e.clientX, y: e.clientY}; document.body.style.cursor = 'grabbing';
    },

    handleMove(e) {
        const world = this.getWorldPos(e);
        this.hoverPin = this.hitTestPin(world.x, world.y);
        if(this.isPanning) {
            this.offsetX += e.clientX - this.lastMouse.x;
            this.offsetY += e.clientY - this.lastMouse.y;
            this.lastMouse = {x: e.clientX, y: e.clientY}; return;
        }
        if(this.dragNode) { this.dragNode.x = world.x - this.dragOffset.x; this.dragNode.y = world.y - this.dragOffset.y; this.propagate(); }
        if(this.tempWire) { this.tempWire.mx = world.x; this.tempWire.my = world.y; }
    },

    handleUp(e) {
        this.isPanning = false; document.body.style.cursor = 'default';
        const world = this.getWorldPos(e);
        if(this.tempWire) {
            const pin = this.hitTestPin(world.x, world.y);
            if(pin && pin.node !== this.tempWire.node && pin.isInput !== this.tempWire.isInput) {
                const from = this.tempWire.isInput ? pin : this.tempWire;
                const to = this.tempWire.isInput ? this.tempWire : pin;
                this.wires = this.wires.filter(w => !(w.toNode === to.node && w.toPin === to.idx));
                this.wires.push({ fromNode: from.node, fromPin: from.idx, toNode: to.node, toPin: to.idx, value: 0 });
                this.propagate();
            }
            this.tempWire = null;
        }
        this.dragNode = null;
    },

    handleRightClick(e) {
        const {x, y} = this.getWorldPos(e);
        const nIdx = this.nodes.findIndex(n => x>=n.x && x<=n.x+n.w && y>=n.y && y<=n.y+n.h);
        if(nIdx !== -1) {
            const node = this.nodes[nIdx];
            this.wires = this.wires.filter(w => w.fromNode !== node && w.toNode !== node);
            this.nodes.splice(nIdx, 1);
            this.propagate();
        }
    },

    handleDblClick(e) {
        const {x, y} = this.getWorldPos(e);
        const nIdx = this.nodes.findIndex(n => x>=n.x && x<=n.x+n.w && y>=n.y && y<=n.y+n.h);
        if(nIdx !== -1) {
            const node = this.nodes[nIdx];
            const newName = prompt("Rename component:", node.label);
            if(newName && newName.trim() !== "") { node.label = newName.trim(); }
        }
    },

    clear() { this.nodes = []; this.wires = []; this.currentEditName = null; this.offsetX = 0; this.offsetY = 0; },
    
    saveChip() {
        let name = prompt("Chip Name:", this.currentEditName || "");
        if(!name) return;
        let lib = JSON.parse(localStorage.getItem('ls_lib')||'{}');
        if(lib[name] && !confirm("Overwrite existing chip?")) return;
        
        const ins = this.nodes.filter(n=>n.type==='Input').sort((a,b)=>a.y-b.y);
        const outs = this.nodes.filter(n=>n.type==='Output').sort((a,b)=>a.y-b.y);
        const inputLabels = ins.map(n => n.label);
        const outputLabels = outs.map(n => n.label);

        const data = {
            name, 
            inputLabels, outputLabels,
            inputCount: ins.length, outputCount: outs.length,
            circuitData: { 
                nodes: this.nodes.map(n => ({
                    id: n.id, type: n.type, x: n.x, y: n.y, 
                    blueprint: n.blueprint, state: n.state, 
                    frequency: n.frequency, label: n.label
                })),
                wires: this.wires.map(w => ({
                    fromNodeId: w.fromNode.id, fromPin: w.fromPin, 
                    toNodeId: w.toNode.id, toPin: w.toPin
                }))
            }
        };
        lib[name] = data;
        localStorage.setItem('ls_lib', JSON.stringify(lib));
        this.loadLibUI();
        this.currentEditName = name;
    },

    exportLib() {
        const lib = localStorage.getItem('ls_lib');
        if(!lib || lib === '{}') { alert("No chips to export."); return; }
        const blob = new Blob([lib], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `logicsim_hybrid_v14_${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    },

    importLib() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = e => {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = event => {
                try {
                    const newLib = JSON.parse(event.target.result);
                    let count = 0;
                    let currentLib = JSON.parse(localStorage.getItem('ls_lib') || '{}');
                    for(let k in newLib) {
                        if(typeof newLib[k].circuitData === 'string') {
                            try { newLib[k].circuitData = JSON.parse(newLib[k].circuitData); } catch(e){}
                        }
                        currentLib[k] = newLib[k];
                        count++;
                    }
                    localStorage.setItem('ls_lib', JSON.stringify(currentLib));
                    this.loadLibUI();
                    alert(`Imported ${count} chips successfully!`);
                } catch(err) { alert("Import Error: " + err.message); }
            };
            reader.readAsText(file);
        };
        input.click();
    },

    testChip(name) {
        if(this.nodes.length > 0 && !confirm("Clear canvas for testing?")) return;
        const lib = JSON.parse(localStorage.getItem('ls_lib')||'{}');
        const bp = lib[name];
        if(!bp) return;

        this.clear();
        document.getElementById('status').innerText = `Testing: ${name}`;

        const centerX = this.c.width / 2 - 50; 
        const centerY = this.c.height / 2 - (Math.max(40, Math.max(bp.inputCount, bp.outputCount) * 20 + 20) / 2);
        const chip = new CustomChip(centerX, centerY, bp);
        this.nodes.push(chip);

        const inputGroups = {}; 
        const keys = [];
        
        bp.inputLabels.forEach((lbl, i) => {
            const match = lbl.match(/^([a-zA-Z]+)/);
            const key = match ? match[1] : "misc";
            if(!inputGroups[key]) {
                inputGroups[key] = [];
                keys.push(key);
            }
            inputGroups[key].push(i);
        });

        keys.forEach((key, colIdx) => {
            const colX = centerX - 100 - ((keys.length - 1 - colIdx) * 80);
            inputGroups[key].forEach(pinIdx => {
                const pinY = chip.ins[pinIdx].y;
                const sw = new Node(colX, chip.y + pinY - 10, 'Input', null, bp.inputLabels[pinIdx]);
                this.nodes.push(sw);
                this.wires.push({ fromNode: sw, fromPin: 0, toNode: chip, toPin: pinIdx, value: 0 });
            });
        });

        const outX = centerX + chip.w + 100;
        bp.outputLabels.forEach((lbl, i) => {
            const pinY = chip.outs[i].y;
            const light = new Node(outX, chip.y + pinY - 10, 'Output', null, lbl);
            this.nodes.push(light);
            this.wires.push({ fromNode: chip, fromPin: i, toNode: light, toPin: 0, value: 0 });
        });

        this.offsetX = 0; this.offsetY = 0;
        this.propagate();
    },

    loadLibUI() {
        const list = document.getElementById('custom-list');
        list.innerHTML = '';
        let lib = JSON.parse(localStorage.getItem('ls_lib')||'{}');
        for(let k in lib) {
            const bp = lib[k];
            const div = document.createElement('div');
            div.className = 'comp-btn';
            const lbl = document.createElement('div');
            lbl.className = 'comp-label';
            lbl.innerHTML = `<span class="icon-indicator" style="background:#888"></span> ${bp.name}`;
            lbl.onclick = () => this.setMode('Custom', bp);
            
            const btnGroup = document.createElement('div');
            btnGroup.className = 'btn-group';
            
            const testBtn = document.createElement('button');
            testBtn.className = 'icon-btn test'; testBtn.innerHTML = 'ðŸ§ª';
            testBtn.title = "Quick Test (Auto-wire)";
            testBtn.onclick = (e) => { e.stopPropagation(); this.testChip(bp.name); };

            const editBtn = document.createElement('button');
            editBtn.className = 'icon-btn'; editBtn.innerHTML = 'âœï¸';
            editBtn.onclick = (e) => { e.stopPropagation(); this.loadForEditing(bp.name); };
            
            const delBtn = document.createElement('button');
            delBtn.className = 'icon-btn delete'; delBtn.innerHTML = 'ðŸ—‘ï¸';
            delBtn.onclick = (e) => { e.stopPropagation(); this.deleteLibItem(bp.name); };
            
            btnGroup.appendChild(testBtn);
            btnGroup.appendChild(editBtn); 
            btnGroup.appendChild(delBtn);
            div.appendChild(lbl); div.appendChild(btnGroup); list.appendChild(div);
        }
    },

    deleteLibItem(name) {
        if(!confirm(`Delete "${name}"?`)) return;
        let lib = JSON.parse(localStorage.getItem('ls_lib')||'{}');
        delete lib[name];
        localStorage.setItem('ls_lib', JSON.stringify(lib));
        this.loadLibUI();
    },

    loadForEditing(name) {
        if(this.nodes.length > 0 && !confirm("Clear canvas?")) return;
        let lib = JSON.parse(localStorage.getItem('ls_lib')||'{}');
        const bp = lib[name];
        if(!bp) return;
        this.clear();
        this.currentEditName = name;
        
        let data = bp.circuitData;
        if(typeof data === 'string') data = JSON.parse(data);

        const nodeMap = {};
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

        data.nodes.forEach(n => {
            let node;
            if(n.type === 'Custom') node = new CustomChip(n.x, n.y, n.blueprint, n.id);
            else node = new Node(n.x, n.y, n.type, n.id, n.label);
            node.state = n.state || 0;
            if(n.type === 'Clock') node.frequency = n.frequency || 1; 
            this.nodes.push(node);
            nodeMap[node.id] = node;
            if(n.x < minX) minX = n.x; if(n.y < minY) minY = n.y;
            if(n.x > maxX) maxX = n.x; if(n.y > maxY) maxY = n.y;
        });

        data.wires.forEach(w => {
            const from = nodeMap[w.fromNodeId]; const to = nodeMap[w.toNodeId];
            if(from && to) this.wires.push({ fromNode: from, fromPin: w.fromPin, toNode: to, toPin: w.toPin, value: 0 });
        });
        
        if(this.nodes.length > 0) {
            this.offsetX = (this.c.width/2) - (minX + (maxX-minX)/2);
            this.offsetY = (this.c.height/2) - (minY + (maxY-minY)/2);
        }
        this.propagate();
        document.getElementById('status').innerText = `Editing: ${name}`;
    }
};

app.init();
</script>
</body>
</html>
