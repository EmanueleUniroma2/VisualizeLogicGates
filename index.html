<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LogicSim JS v6.0 - Library Management</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-color: #252526;
            --accent-color: #007acc;
            --text-color: #d4d4d4;
            --wire-off: #555;
            --wire-on: #4caf50;
            --clock-color: #8e44ad;
            --danger-color: #d9534f;
        }
        body { margin: 0; background: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; }
        
        /* Sidebar */
        #sidebar { width: 240px; background: var(--panel-color); padding: 10px; border-right: 1px solid #333; display: flex; flex-direction: column; gap: 5px; overflow-y: auto; }
        h3 { font-size: 0.9rem; color: #888; text-transform: uppercase; margin: 15px 0 5px 0; border-bottom: 1px solid #444; }
        
        .comp-btn { 
            background: #333; color: white; border: 1px solid #444; padding: 6px; cursor: pointer; 
            display: flex; align-items: center; justify-content: space-between; border-radius: 4px; transition: 0.2s;
            min-height: 30px;
        }
        .comp-btn:hover { background: #444; }
        .comp-label { display: flex; align-items: center; gap: 10px; flex-grow: 1; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        
        /* Button Group for Edit/Delete */
        .btn-group { display: flex; gap: 4px; }
        
        .icon-btn { 
            padding: 4px 6px; border-radius: 3px; cursor: pointer; font-size: 12px; 
            background: #555; border: none; color: white; display: flex; align-items: center; justify-content: center;
        }
        .icon-btn:hover { background: var(--accent-color); }
        .icon-btn.delete:hover { background: var(--danger-color); }

        .icon-indicator { width: 10px; height: 10px; border-radius: 50%; display: inline-block; flex-shrink: 0; }

        /* Canvas */
        #canvas-box { flex-grow: 1; position: relative; background: radial-gradient(#333 1px, transparent 1px) 0 0 / 20px 20px; }
        
        #toolbar { position: absolute; top: 10px; right: 10px; display: flex; gap: 10px; }
        .tool-btn { padding: 8px 16px; background: var(--accent-color); border: none; color: white; border-radius: 4px; cursor: pointer; font-weight: bold; }
        .tool-btn.danger { background: var(--danger-color); }
        
        #status { position: fixed; bottom: 10px; right: 10px; background: #333; padding: 5px 12px; border-radius: 20px; font-size: 0.85em; opacity: 0.8; border: 1px solid #555; }
        
        .hint { font-size: 0.75rem; color: #777; margin-top: 5px; text-align: center; font-style: italic;}
    </style>
</head>
<body>

<div id="sidebar">
    <h3>I/O</h3>
    <div class="comp-btn" onclick="app.setMode('Input')">
        <div class="comp-label"><span class="icon-indicator" style="background:green"></span>Switch</div>
    </div>
    <div class="comp-btn" onclick="app.setMode('Clock')">
        <div class="comp-label"><span class="icon-indicator" style="background:var(--clock-color)"></span>Clock</div>
    </div>
    <div class="comp-btn" onclick="app.setMode('Output')">
        <div class="comp-label"><span class="icon-indicator" style="background:orange"></span>Light</div>
    </div>
    
    <h3>Logic Gates</h3>
    <div class="comp-btn" onclick="app.setMode('AND')"><div class="comp-label">AND</div></div>
    <div class="comp-btn" onclick="app.setMode('OR')"><div class="comp-label">OR</div></div>
    <div class="comp-btn" onclick="app.setMode('NOT')"><div class="comp-label">NOT</div></div>
    <div class="comp-btn" onclick="app.setMode('NAND')"><div class="comp-label">NAND</div></div>
    <div class="comp-btn" onclick="app.setMode('XOR')"><div class="comp-label">XOR</div></div>

    <h3>My Chips</h3>
    <div id="custom-list"></div>
    <div class="hint">Tasto DX per eliminare dalla canvas</div>
</div>

<div id="canvas-box">
    <div id="toolbar">
        <button class="tool-btn" onclick="app.saveChip()">Salva Chip</button>
        <button class="tool-btn danger" onclick="app.clear()">Pulisci Tutto</button>
    </div>
    <canvas id="c"></canvas>
    <div id="status">Pronto</div>
</div>

<script>
// --- UTILS ---
const dist = (x1, y1, x2, y2) => Math.hypot(x2-x1, y2-y1);

// --- CLASSES ---
class Node {
    constructor(x, y, type, id = null) {
        this.id = id || Math.random().toString(36).substr(2, 9);
        this.x = x; this.y = y;
        this.type = type;
        this.w = 60; this.h = 40;
        
        this.state = 0; 
        this.currentValue = 0; 
        
        if (this.type === 'Clock') {
            this.frequency = 1; 
            this.lastTick = Date.now();
        }

        this.ins = []; this.outs = [];
        this.setupPins();
    }

    setupPins() {
        if (this.type === 'Input' || this.type === 'Clock') {
            this.outs = [{x:60, y:20}];
        } else if (this.type === 'Output') {
            this.ins = [{x:0, y:20}];
        } else if (this.type === 'NOT') { 
            this.ins = [{x:0, y:20}]; this.outs = [{x:60, y:20}]; 
        } else { 
            // Gates
            this.ins = [{x:0, y:10}, {x:0, y:30}]; 
            this.outs = [{x:60, y:20}]; 
        }
    }

    compute(inputs) {
        const a = inputs[0] || 0;
        const b = inputs[1] || 0;
        switch(this.type) {
            case 'Input': 
            case 'Clock': return [this.state];
            case 'Output': this.currentValue = a; return [];
            case 'AND': return [a && b ? 1 : 0];
            case 'OR': return [a || b ? 1 : 0];
            case 'NOT': return [a ? 0 : 1];
            case 'NAND': return [!(a && b) ? 1 : 0];
            case 'XOR': return [a ^ b ? 1 : 0];
            default: return [0];
        }
    }
}

class CustomChip extends Node {
    constructor(x, y, blueprint, id = null) {
        super(x, y, 'Custom', id);
        this.blueprint = blueprint;
        this.label = blueprint.name;
        
        const maxPins = Math.max(blueprint.inputCount, blueprint.outputCount);
        this.h = Math.max(40, maxPins * 20 + 20);
        this.w = 80;

        this.ins = [];
        for(let i=0; i<blueprint.inputCount; i++) this.ins.push({x:0, y: (this.h/(blueprint.inputCount+1))*(i+1)});
        this.outs = [];
        for(let i=0; i<blueprint.outputCount; i++) this.outs.push({x:this.w, y: (this.h/(blueprint.outputCount+1))*(i+1)});

        const data = JSON.parse(blueprint.circuitData);
        const innerNodeMap = {};

        this.innerNodes = data.nodes.map(n => {
            let node;
            if (n.type === 'Custom') node = new CustomChip(0, 0, n.blueprint, n.id);
            else node = new Node(0, 0, n.type, n.id);
            node.state = n.state || 0;
            if(n.type === 'Clock') node.frequency = n.frequency || 1;
            innerNodeMap[node.id] = node;
            return node;
        });

        this.innerWires = data.wires.map(w => ({
            fromNode: innerNodeMap[w.fromNodeId], fromPin: w.fromPin,
            toNode: innerNodeMap[w.toNodeId], toPin: w.toPin
        })).filter(w => w.fromNode && w.toNode);
    }

    compute(inputs) {
        const iNodes = this.innerNodes.filter(n => n.type === 'Input').sort((a,b)=>a.y - b.y);
        iNodes.forEach((n, i) => n.state = inputs[i] || 0);

        const now = Date.now();
        this.innerNodes.forEach(n => {
            if(n.type === 'Clock') {
                const halfPeriod = (1000 / n.frequency) / 2;
                if(now - n.lastTick > halfPeriod) {
                    n.state = !n.state;
                    n.lastTick = now;
                }
            }
        });

        for(let pass=0; pass < this.innerNodes.length * 2; pass++) {
            this.innerNodes.forEach(n => {
                const nodeIns = n.ins.map((_, pinIdx) => {
                    const wire = this.innerWires.find(w => w.toNode === n && w.toPin === pinIdx);
                    if(!wire) return 0;
                    const src = wire.fromNode;
                    return src.lastResult ? src.lastResult[wire.fromPin] : 0;
                });
                n.lastResult = n.compute(nodeIns);
                if(n.type === 'Output') n.currentValue = nodeIns[0];
            });
        }

        const oNodes = this.innerNodes.filter(n => n.type === 'Output').sort((a,b)=>a.y - b.y);
        return oNodes.map(n => n.currentValue || 0);
    }
}

// --- APP CONTROLLER ---
const app = {
    c: document.getElementById('c'),
    ctx: document.getElementById('c').getContext('2d'),
    nodes: [],
    wires: [],
    mode: null,
    blueprint: null,
    tempWire: null,
    hoverPin: null,
    currentEditName: null, 

    init() {
        this.resize();
        window.onresize = () => this.resize();
        this.loadLibUI();
        this.loop();
        
        // Events
        this.c.onmousedown = e => this.handleDown(e);
        this.c.onmousemove = e => this.handleMove(e);
        this.c.onmouseup = e => this.handleUp(e);
        this.c.oncontextmenu = e => { e.preventDefault(); this.handleRightClick(e); };
    },

    resize() {
        this.c.width = this.c.parentElement.clientWidth;
        this.c.height = this.c.parentElement.clientHeight;
    },

    setMode(m, bp = null) { 
        this.mode = m; 
        this.blueprint = bp;
        document.getElementById('status').innerText = m ? `Piazza: ${bp ? bp.name : m}` : "Pronto";
    },

    addNode(x, y) {
        if(this.mode === 'Custom') this.nodes.push(new CustomChip(x, y, this.blueprint));
        else this.nodes.push(new Node(x, y, this.mode));
        this.setMode(null);
        this.propagate();
    },

    // --- LOGIC ---
    updateClocks() {
        const now = Date.now();
        let changed = false;
        this.nodes.forEach(n => {
            if (n.type === 'Clock') {
                const halfPeriod = (1000 / n.frequency) / 2;
                if (now - n.lastTick > halfPeriod) {
                    n.state = !n.state;
                    n.lastTick = now;
                    changed = true;
                }
            }
            if (n.type === 'Custom' && this.hasInternalClock(n)) changed = true;
        });
        if (changed) this.propagate();
    },
    
    hasInternalClock(customNode) {
        return customNode.innerNodes.some(n => n.type === 'Clock' || (n.type === 'Custom' && this.hasInternalClock(n)));
    },

    propagate() {
        for(let i=0; i<this.nodes.length + 5; i++) {
            this.nodes.forEach(n => {
                const inputs = n.ins.map((_, idx) => {
                    const w = this.wires.find(w => w.toNode === n && w.toPin === idx);
                    return w ? w.value : 0;
                });
                const outputs = n.compute(inputs);
                outputs.forEach((val, idx) => {
                    this.wires.filter(w => w.fromNode === n && w.fromPin === idx)
                              .forEach(w => w.value = val);
                });
            });
        }
    },

    // --- RENDERING ---
    drawGateShape(ctx, n) {
        ctx.beginPath();
        const x = n.x, y = n.y, w = n.w, h = n.h;

        // Custom Chips (Box)
        if(n.type === 'Custom' || n.type === 'Input' || n.type === 'Output' || n.type === 'Clock') {
            ctx.rect(x, y, w, h);
            return;
        }

        if (n.type === 'AND' || n.type === 'NAND') {
            ctx.moveTo(x, y); ctx.lineTo(x + w/2, y);
            ctx.arc(x + w/2, y + h/2, h/2, -Math.PI/2, Math.PI/2);
            ctx.lineTo(x, y + h); ctx.closePath();
        } 
        else if (n.type === 'OR' || n.type === 'NOR') {
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(x + w/4, y + h/2, x, y + h); 
            ctx.quadraticCurveTo(x + w/2, y + h - 5, x + w, y + h/2);
            ctx.quadraticCurveTo(x + w/2, y + 5, x, y); 
            ctx.closePath();
        }
        else if (n.type === 'XOR') {
            const off = 6;
            ctx.moveTo(x + off, y);
            ctx.quadraticCurveTo(x + w/4 + off, y + h/2, x + off, y + h);
            ctx.quadraticCurveTo(x + w/2 + off, y + h - 5, x + w, y + h/2);
            ctx.quadraticCurveTo(x + w/2 + off, y + 5, x + off, y);
            ctx.closePath();
        }
        else if (n.type === 'NOT') {
            ctx.moveTo(x, y); ctx.lineTo(x + w - 10, y + h/2); ctx.lineTo(x, y + h); ctx.closePath();
        }
    },

    drawDecorations(ctx, n) {
        if (n.type === 'XOR') {
            ctx.beginPath(); ctx.strokeStyle = '#ccc'; ctx.lineWidth = 2;
            ctx.moveTo(n.x - 4, n.y);
            ctx.quadraticCurveTo(n.x + n.w/4 - 4, n.y + n.h/2, n.x - 4, n.y + n.h);
            ctx.stroke();
        }
        if (n.type === 'NAND' || n.type === 'NOR' || n.type === 'NOT') {
            ctx.beginPath(); ctx.fillStyle = '#1e1e1e'; ctx.strokeStyle = '#ccc'; ctx.lineWidth = 1;
            let bx = n.x + n.w, by = n.y + n.h/2;
            if (n.type === 'NOT') bx = n.x + n.w - 5;
            ctx.arc(bx, by, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        }
    },

    loop() {
        this.updateClocks();
        const ctx = this.ctx;
        ctx.clearRect(0,0, this.c.width, this.c.height);
        
        // Wires
        this.wires.forEach(w => {
            const start = {x: w.fromNode.x + w.fromNode.outs[w.fromPin].x, y: w.fromNode.y + w.fromNode.outs[w.fromPin].y};
            const end = {x: w.toNode.x + w.toNode.ins[w.toPin].x, y: w.toNode.y + w.toNode.ins[w.toPin].y};
            ctx.beginPath();
            ctx.strokeStyle = w.value ? 'var(--wire-on)' : 'var(--wire-off)';
            ctx.lineWidth = 3;
            ctx.moveTo(start.x, start.y);
            ctx.bezierCurveTo(start.x+40, start.y, end.x-40, end.y, end.x, end.y);
            ctx.stroke();
        });

        if(this.tempWire) {
            const start = {x: this.tempWire.node.x + (this.tempWire.isInput?this.tempWire.node.ins:this.tempWire.node.outs)[this.tempWire.idx].x, y: this.tempWire.node.y + (this.tempWire.isInput?this.tempWire.node.ins:this.tempWire.node.outs)[this.tempWire.idx].y};
            ctx.beginPath(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
            ctx.moveTo(start.x, start.y); ctx.lineTo(this.tempWire.mx, this.tempWire.my); ctx.stroke();
        }

        // Nodes
        this.nodes.forEach(n => {
            this.drawGateShape(ctx, n);
            ctx.fillStyle = '#333'; 
            ctx.strokeStyle = (n === this.dragNode) ? '#fff' : '#ccc';
            if(n.type === 'Clock') ctx.strokeStyle = 'var(--clock-color)';
            ctx.lineWidth = 2;
            ctx.fill(); ctx.stroke();
            this.drawDecorations(ctx, n);

            // Label
            ctx.fillStyle = '#aaa'; ctx.textAlign = 'center'; ctx.font = '11px sans-serif';
            let label = n.label || n.type;
            if(n.type === 'Clock') label = `${n.frequency}Hz`;
            ctx.fillText(label, n.x+n.w/2, n.y + n.h + 15);

            // Indicators
            if(n.type === 'Input') { ctx.fillStyle = n.state ? '#0f0' : '#222'; ctx.fillRect(n.x+10, n.y+10, 20, 20); }
            if(n.type === 'Clock') { ctx.fillStyle = n.state ? '#d2a4ff' : '#4a235a'; ctx.fillRect(n.x+10, n.y+10, 20, 20); }
            if(n.type === 'Output') { ctx.fillStyle = n.currentValue ? '#ff0' : '#220'; ctx.beginPath(); ctx.arc(n.x+n.w/2, n.y+n.h/2, 10, 0, Math.PI*2); ctx.fill(); }

            // Pins
            const drawP = (pins, isInput) => pins.forEach((p, i) => {
                const px = n.x + p.x, py = n.y + p.y;
                const hov = this.hoverPin && this.hoverPin.node === n && this.hoverPin.idx === i && this.hoverPin.isInput === isInput;
                ctx.fillStyle = hov ? '#fff' : '#999';
                const s = hov ? 10 : 6;
                ctx.fillRect(px-s/2, py-s/2, s, s);
            });
            drawP(n.ins, true); drawP(n.outs, false);
        });
        requestAnimationFrame(() => this.loop());
    },

    // --- INTERACTION ---
    getMouse(e) { const r = this.c.getBoundingClientRect(); return {x: e.clientX - r.left, y: e.clientY - r.top}; },
    
    hitTestPin(mx, my) {
        for(let n of this.nodes) {
            for(let i=0; i<n.ins.length; i++) {
                const p = n.ins[i];
                if(dist(mx, my, n.x+p.x, n.y+p.y) < 15) return {node:n, idx:i, isInput:true};
            }
            for(let i=0; i<n.outs.length; i++) {
                const p = n.outs[i];
                if(dist(mx, my, n.x+p.x, n.y+p.y) < 15) return {node:n, idx:i, isInput:false};
            }
        }
        return null;
    },

    handleRightClick(e) {
        const {x, y} = this.getMouse(e);
        const nIdx = this.nodes.findIndex(n => x>=n.x && x<=n.x+n.w && y>=n.y && y<=n.y+n.h);
        if(nIdx !== -1) {
            const node = this.nodes[nIdx];
            this.wires = this.wires.filter(w => w.fromNode !== node && w.toNode !== node);
            this.nodes.splice(nIdx, 1);
            this.propagate();
        }
    },

    handleDown(e) {
        if(e.button === 2) return;
        const {x, y} = this.getMouse(e);
        const pin = this.hitTestPin(x, y);
        if(pin) { this.tempWire = {...pin, mx:x, my:y}; return; }

        for(let i = this.nodes.length-1; i>=0; i--) {
            const n = this.nodes[i];
            if(x>=n.x && x<=n.x+n.w && y>=n.y && y<=n.y+n.h) {
                if(n.type === 'Input') { n.state = !n.state; this.propagate(); }
                else if (n.type === 'Clock') {
                    const input = prompt(`Frequenza (0.01Hz - 5Hz)`, n.frequency);
                    if (input !== null) { const val = parseFloat(input); if(val >= 0.01 && val <= 5) n.frequency = val; }
                } 
                else { this.dragNode = n; this.dragOffset = {x: x-n.x, y: y-n.y}; }
                return;
            }
        }
        if(this.mode) this.addNode(x-30, y-20);
    },

    handleMove(e) {
        const {x, y} = this.getMouse(e);
        this.hoverPin = this.hitTestPin(x, y);
        if(this.dragNode) { this.dragNode.x = x - this.dragOffset.x; this.dragNode.y = y - this.dragOffset.y; this.propagate(); }
        if(this.tempWire) { this.tempWire.mx = x; this.tempWire.my = y; }
    },

    handleUp(e) {
        const {x, y} = this.getMouse(e);
        if(this.tempWire) {
            const pin = this.hitTestPin(x, y);
            if(pin && pin.node !== this.tempWire.node && pin.isInput !== this.tempWire.isInput) {
                const from = this.tempWire.isInput ? pin : this.tempWire;
                const to = this.tempWire.isInput ? this.tempWire : pin;
                this.wires = this.wires.filter(w => !(w.toNode === to.node && w.toPin === to.idx));
                this.wires.push({ fromNode: from.node, fromPin: from.idx, toNode: to.node, toPin: to.idx, value: 0 });
                this.propagate();
            }
            this.tempWire = null;
        }
        this.dragNode = null;
    },

    // --- SAVE/LOAD ---
    clear() { this.nodes = []; this.wires = []; this.currentEditName = null; },
    
    saveChip() {
        let name = prompt("Nome Chip:", this.currentEditName || "");
        if(!name) return;
        let lib = JSON.parse(localStorage.getItem('ls_lib')||'{}');
        if(lib[name] && !confirm("Sovrascrivere?")) return;

        const ins = this.nodes.filter(n=>n.type==='Input').sort((a,b)=>a.y-b.y);
        const outs = this.nodes.filter(n=>n.type==='Output').sort((a,b)=>a.y-b.y);
        
        const data = {
            name, inputCount: ins.length, outputCount: outs.length,
            circuitData: JSON.stringify({
                nodes: this.nodes.map(n => ({
                    id: n.id, type: n.type, x: n.x, y: n.y, 
                    blueprint: n.blueprint, state: n.state, 
                    frequency: n.frequency 
                })),
                wires: this.wires.map(w => ({
                    fromNodeId: w.fromNode.id, fromPin: w.fromPin, 
                    toNodeId: w.toNode.id, toPin: w.toPin
                }))
            })
        };
        lib[name] = data;
        localStorage.setItem('ls_lib', JSON.stringify(lib));
        this.loadLibUI();
        this.currentEditName = name;
    },

    loadLibUI() {
        const list = document.getElementById('custom-list');
        list.innerHTML = '';
        let lib = JSON.parse(localStorage.getItem('ls_lib')||'{}');
        
        for(let k in lib) {
            const bp = lib[k];
            const div = document.createElement('div');
            div.className = 'comp-btn';
            
            // Label
            const lbl = document.createElement('div');
            lbl.className = 'comp-label';
            lbl.innerHTML = `<span class="icon-indicator" style="background:#888"></span> ${bp.name}`;
            lbl.title = "Clicca per piazzare";
            lbl.onclick = () => this.setMode('Custom', bp);
            
            // Button Group
            const btnGroup = document.createElement('div');
            btnGroup.className = 'btn-group';

            // Edit
            const editBtn = document.createElement('button');
            editBtn.className = 'icon-btn';
            editBtn.innerHTML = 'âœï¸';
            editBtn.title = "Modifica Circuito";
            editBtn.onclick = (e) => { e.stopPropagation(); this.loadForEditing(bp.name); };
            
            // Delete
            const delBtn = document.createElement('button');
            delBtn.className = 'icon-btn delete';
            delBtn.innerHTML = 'ðŸ—‘ï¸';
            delBtn.title = "Elimina Definitivamente";
            delBtn.onclick = (e) => { e.stopPropagation(); this.deleteLibItem(bp.name); };

            btnGroup.appendChild(editBtn);
            btnGroup.appendChild(delBtn);

            div.appendChild(lbl); 
            div.appendChild(btnGroup); 
            list.appendChild(div);
        }
    },

    deleteLibItem(name) {
        if(!confirm(`Sei sicuro di voler eliminare "${name}" dalla libreria? Questa azione Ã¨ irreversibile.`)) return;
        let lib = JSON.parse(localStorage.getItem('ls_lib')||'{}');
        delete lib[name];
        localStorage.setItem('ls_lib', JSON.stringify(lib));
        this.loadLibUI();
    },

    loadForEditing(name) {
        if(this.nodes.length > 0 && !confirm("Pulisci canvas?")) return;
        let lib = JSON.parse(localStorage.getItem('ls_lib')||'{}');
        const bp = lib[name];
        if(!bp) return;

        this.clear();
        this.currentEditName = name;
        const data = JSON.parse(bp.circuitData);
        const nodeMap = {};

        data.nodes.forEach(n => {
            let node;
            if(n.type === 'Custom') node = new CustomChip(n.x, n.y, n.blueprint, n.id);
            else node = new Node(n.x, n.y, n.type, n.id);
            node.state = n.state || 0;
            if(n.type === 'Clock') node.frequency = n.frequency || 1; 
            this.nodes.push(node);
            nodeMap[node.id] = node;
        });

        data.wires.forEach(w => {
            const from = nodeMap[w.fromNodeId]; const to = nodeMap[w.toNodeId];
            if(from && to) this.wires.push({ fromNode: from, fromPin: w.fromPin, toNode: to, toPin: w.toPin, value: 0 });
        });

        this.propagate();
        document.getElementById('status').innerText = `Editing: ${name}`;
    }
};

app.init();
</script>
</body>
</html>
